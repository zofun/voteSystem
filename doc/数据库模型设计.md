## MongoDB
### User
```
{
  "_id":ObjectId(),
  "username":"123456",
  "password": "123456",
  "role": "admin/user"
  "vote":10

}
```
说明：
vote记录的是该用户当前可用的选票

### Competitor
```
{
    "_id":ObjectId(),
    "cid":000001,
    "name":"小明",
    "nickname":"黑旋风",
    "tel":"13778143356",
    "state":"1/0"
    "vote_num":36
}

```
- cid是参赛者的唯一编号
- 参赛者的状态有两种1（参赛状态，报名后的初始状态）；0（退赛状态）
### votes
```
{
    "_id":ObjectId(),
    "cid":"000001",
    "username":"tony"，
    "date":"1593270677390610",
    "vote_num":1
}
```
说明：
- data是投票时间,直接存时间戳
- vote_num:是本次投票加票的票数，普通用户每次投票加票的票数为1，而管理员自由指定


## redis
1. 用于计算排名的zset
- key=REDIS_RANKING_LIST_KEY
- member:cid
- score:vote_num(高32位)+timestamp(低32位)

2. 保存参赛者信息 每个参赛者维护一个string
- key:cid
- value:{'name': competitor['name'], 'nickname': competitor['nickname']
                    , 'tel': competitor['tel'], 'vote_num': competitor['vote_num'], "cid": competitor['cid']}
            
3. 记录投票信息的String
- key:username+REDIS_SPLIT+cid
- value:vote_num


说明：
- 使用zset来实现排行榜排序等操作，因此zset是在第一次请求排行榜的时候一次性加载到redis中
- 请求参赛者信息缓存未命中的时候才从数据库中读取加载到redis中
- 投票的时候，查询是否重复投票是依赖于redis中的set来实现的，只有在缓存未命中的时候才从数据库中读取，加载到redis中


拓展功能：
1. 每天0点重置排行榜，可以查询之前7天的排行榜信息
设置定时任务，在当前零点完成数据存档到mongo，并重置users的vote，competitor的信息,清空当天的vote信息。

2. 每人每天最多能投N次票，但是对于同一个人最多能投M次
实现思路：在mongo users集合中为每个用户维护一个拥有的选票，每次投票的时候查库判断是否还有选票<br/>
同时在redis中判断为该用户的投票是否超过M次

3. 排行榜分数相同的时，按到达的时间排序
排行榜依然使用zset来实现，在score上做文章，将选票数作为score的高32位，截取最后一次投票的时间戳做低32位。